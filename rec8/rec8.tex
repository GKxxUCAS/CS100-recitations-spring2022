\documentclass{beamer}

\usepackage{../cppenv}
\usepackage{../recdefs}

\usetheme{PaloAlto}
\usecolortheme{spruce}

\title{CS100 Recitation 8}
\author{GKxx}
\date{April 11, 2022}

\AtBeginSubsection{
    \begin{frame}{Contents}
        \tableofcontents[currentsection, currentsubsection]
    \end{frame}
}

\begin{document}

\begin{frame}
    \maketitle
\end{frame}

\section{Copy Control}

\subsection{Copying an Object}

\begin{frame}[fragile]{When Copy Happens}
    \begin{cpp}
class Point2d {
  double x, y;
 public:
  Point2d() : Point2d(0, 0) {}
  Point2d(double a, double b) : x(a), y(b) {}
};
    \end{cpp}
    \begin{question}
        What member functions have been synthesized by the compiler?
    \end{question}
\end{frame}

\begin{frame}[fragile]{When Copy Happens}
    \begin{cpp}
class Point2d {
  double x, y;
 public:
  Point2d() : Point2d(0, 0) {}
  Point2d(double a, double b) : x(a), y(b) {}
};
    \end{cpp}
    When we have the class definition above, there are \blue{3} ways of constructing an object:
    \begin{cpp}
Point2d p0;
Point2d p1(3.14, 6.28);
Point2d p2(p1); // same as Point2d p2 = p1;
    \end{cpp}
\end{frame}

\begin{frame}[fragile]{When Copy Happens}
    \begin{cpp}
class Point2d {
  double x, y;
 public:
  Point2d() : Point2d(0, 0) {}
  Point2d(double a, double b) : x(a), y(b) {}
};
    \end{cpp}
    We can also pass \ttt{Point2d} objects as arguments, or as return-values:
    \begin{cpp}
// BAD!! You should use reference-to-const.
Point2d less_in_x(Point2d lhs, Point2d rhs) {
  return lhs.get_x() < rhs.get_x() ? lhs : rhs;
}
    \end{cpp}
\end{frame}

\begin{frame}[fragile]{When Copy Happens}
    How many copies are created?
    \begin{cpp}
Point2d p3 = less_in_x(p0, p1);
    \end{cpp}
    \pause
    \begin{itemize}
        \item Copy-initialize the parameters \ttt{lhs} and \ttt{rhs}.
        \item Copy-initialize a temporary object generated by the calling expression with the return value. \red{(?)}
        \item Copy-initialize \ttt{p3}. \red{(not assignment!)}
    \end{itemize}
    \pause
    Copying a return-value?
    \begin{itemize}
        \item Many compilers avoid such copying by \blue{Return Value Optimization (RVO)}.
        \item Since C++11, a local object will be returned by \blue{moving} instead of \blue{copying}, if it is \blue{move-constructible}.
        \item C++17 guarantees that this copy won't happen, even when the object is not move-constructible.
    \end{itemize}
\end{frame}

\subsection{The Copy Constructor}

\begin{frame}[fragile]{The Copy Constructor}
    The \blue{copy ctor} defines the behavior of copy initializing an object.
    \begin{cpp}
class Point2d {
 public:
  Point2d(const Point2d &other)
    : x(other.x), y(other.y) {}
  // other members
};
    \end{cpp}
    \pause
    \begin{itemize}
        \item Can we define the parameter type as \ttt{Point2d} instead of reference-to-\bluett{const}?
        \item Can we define the parameter type as \ttt{Point2d \&}?
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{The Copy Constructor}
    \begin{cpp}
class Vector {
  std::size_t m_size, m_capacity;
  int *m_data;
 public:
  Vector(const Vector &other)
    : m_size(other.m_size),
      m_capacity(other.m_capacity),
      m_data(new int[m_capacity]{}) {
    for (std::size_t i = 0; i < m_size; ++i)
      m_data[i] = other.m_data[i];
  }
  // other members
};
    \end{cpp}
\end{frame}

\subsection{The Copy-Assignment Operator}

\begin{frame}[fragile]{The Copy-Assignment Operator}
    The behavior of assignment like
    \begin{cpp}
Point2d p1, p2;
p1 = p2;
    \end{cpp}
    is defined by the \blue{copy-assignment operator}. It is defined by \blue{overloading} the assignment operator.
    \begin{cpp}
class Point2d {
 public:
  Point2d &operator=(const Point2d &other) {
    x = other.x;
    y = other.y;
    return *this;
  }
};
    \end{cpp}
\end{frame}

\begin{frame}[fragile]{The Copy-Assignment Operator}
    \begin{cpp}
class Point2d {
 public:
  Point2d &operator=(const Point2d &other) {
    x = other.x;
    y = other.y;
    // return reference to the object itself
    return *this;
  }
};
    \end{cpp}
    \begin{notice}
        You should make the overloaded operator behave as similar to the built-in one as possible.
    \end{notice}
\end{frame}

\begin{frame}[fragile]{The Copy-Assignment Operator}
    When an assignment happens, the left-hand operand is bound to the implicit \bluett{this}. The right-hand operand is passed as the parameter.
    \begin{cpp}
Point2d p1, p2;
p1 = p2;
p1.operator=(p2); // equivalent way
    \end{cpp}
    \pause
    Since the assignment operator returns the object on the left-hand side, we can chain assignments together:
    \begin{cpp}
p1 = p2 = p3;
    \end{cpp}
\end{frame}

\begin{frame}[fragile]{Copy-Assignment of Vector}
    \begin{cpp}
class Vector {
 public:
  Vector &operator=(const Vector &other) {
    delete[] m_data;
    m_size = other.m_size;
    m_capacity = other.m_capacity;
    m_data = new int[m_capacity];
    for (std::size_t i = 0; i < m_size; ++i)
      m_data[i] = other.m_data[i];
    return *this;
  }
  // other members
};
    \end{cpp}
    \pause
    \begin{itemize}
        \item Anything wrong with this assignment operator?
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Self-assignment Safety}
    \begin{itemize}
        \item Should self-assignment happen, the data is \bluett{delete}d at first! It becomes a disaster.
        \item \gray{Exception-safety issue.}
    \end{itemize}
    \pause
    Self-assignment may happen unnoticed and without a warning:
    \begin{cpp}
Vector v = some_value();
Vector &rv = some_function(v);
v = rv;
    \end{cpp}
    \begin{notice}
        Assignment operator should always be \blue{self-assignment-safe}.
    \end{notice}
\end{frame}

\begin{frame}[fragile]{The Correct Way}
    \begin{cpp}
class Vector {
 public:
  Vector &operator=(const Vector &other) {
    int *new_data = new int[other.m_capacity];
    for (std::size_t i = 0; i < other.m_size; ++i)
      new_data[i] = other.m_data[i];
    m_size = other.m_size;
    m_capacity = other.m_capacity;
    delete[] m_data;
    m_data = new_data;
    return *this;
  }
};
    \end{cpp}
\end{frame}

\begin{frame}[fragile]{Still Problematic Way}
    \begin{cpp}
Vector &Vector::operator=(const Vector &other) {
  // test self-assignment directly
  if (this != &other) {
    delete[] m_data;
    m_size = other.m_size;
    m_capacity = other.m_capacity;
    m_data = new int[m_capacity];
    for (std::size_t i = 0; i < m_size; ++i)
      m_data[i] = other.m_data[i];
  }
  return *this;
}
    \end{cpp}
    \begin{itemize}
        \item This handles self-assignment correctly, but \textbf{still has exception-safety issue}.
    \end{itemize}
\end{frame}

\subsection{Synthesized Copy Operations}

\begin{frame}{Synthesized Copy Ctor}
    The compiler will synthesize a copy ctor if
    \begin{itemize}
        \item the copy ctor is not defined, and
        \item every member is \blue{copy-constructible}.
    \end{itemize}
    The synthesized copy ctor will copy-initialize the members one-by-one, and has an empty function body.
    \begin{question}
        Is it ok for \ttt{Point2d} to use the synthesized copy ctor? What about \ttt{Vector}?
    \end{question}
\end{frame}

\begin{frame}{Synthesized Copy-Assignment Operator}
    The compiler will synthesize a copy-assignment operator if
    \begin{itemize}
        \item the copy-assignment operator is not defined, and
        \item every member is \blue{copy-assignable}.
    \end{itemize}
    The synthesized copy-assignment operator will copy-assign the members one-by-one, and of course return \ttt{*}\bluett{this}.
    \pause
    \begin{question}
        Is it ok for \ttt{Point2d} to use the synthesized copy-assignment operator? What about \ttt{Vector}?
    \end{question}
\end{frame}

\begin{frame}[fragile]{Copying Array Members}
    It is not allowed to copy arrays directly like
    \begin{cpp}
int a[100], b[100];
a = b;
    \end{cpp}
    But if there's an array member, the synthesized copy operations will copy the elements in the array one-by-one. Don't worry!
\end{frame}

\begin{frame}[fragile]{Use \ttt{=default}}
    For a \blue{default ctor}, a \blue{copy ctor}, a \blue{copy-assignment operator} or a \blue{destructor}, we can explicitly require the compiler to synthesize one with defaulted behavior by \ttt{=default}:
    \begin{cpp}
class Point2d {
  double x, y;
 public:
  Point2d() = default;
  Point2d(const Point2d &) = default;
  Point2d &operator=(const Point2d &) = default;
  ~Point2d() = default;
  // other members
};
    \end{cpp}
\end{frame}

\begin{frame}{The Rule of Three}
    \begin{theorem}[The Rule of Three]
        If a class needs one of the three copy-controlling operations (copy-ctor, copy-assignment operator and destructor), it is highly possible that all of them are needed.
    \end{theorem}
    \begin{itemize}
        \item Such idea was not so widely acknowledged when C++98 came out. Therefore, the compiler will still generate the others if you only define one or two of them.
        \item We will see changes in C++11 when we talk about \textbf{moving}.
    \end{itemize}
\end{frame}

\subsection{Prevent Copying}

\begin{frame}{Prevent Copying}
    Some class, like \ttt{std::istream}, should avoid copying. (Why?)
    \begin{question}
        Can we prevent copying by simply not defining the copy operations?
    \end{question}
    \pause
    Before C++11, people prevent copying by \textbf{declaring the copying operations as private, and not defining them}.
    \begin{itemize}
        \item Attempts to copy such an object outside the class and out of a friend will cause an error in access-level.
        \item Attempts to copy inside the class or in a friend will cause a linking error.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Deleted Functions}
    Since C++11, we can define a function as \textbf{deleted} by defining it to be \ttt{=delete}.
    \begin{cpp}
class Uncopyable {
 public:
  Uncopyable(const Uncopyable &) = delete;
  Uncopyable &operator=(const Uncopyable &) = delete;
};
    \end{cpp}
    \pause
    Use \ttt{=delete} to avoid copying in modern C++!
    \pause
    \begin{notice}
        If we define a special member function to be \ttt{=default} but the compiler cannot synthesize it, it is implicitly \textbf{deleted} and will not cause an error (but will generate a warning).
    \end{notice}
\end{frame}

\begin{frame}{Recommended Reading Materials}
    \begin{itemize}
        \item \textit{Effective C++}, Item 5: Know what functions C++ silently writes and calls.
        \item \textit{Effective C++}, Item 6: Explicitly disallow the use of compiler-generated functions you do not want.
    \end{itemize}
\end{frame}

\section{More about Class}

\subsection{Constructors and Type-casting}

\begin{frame}[fragile]{Constructors and Type-casting}
    A constructor also defines a type-casting:
    \begin{cpp}
void fun(std::string s) {
  // do something
}
int main() {
  fun("Hello world");
  return 0;
}
    \end{cpp}
    \begin{itemize}
        \item \ttt{std::string} has a constructor that accepts a \bluett{const char }\ttt{*} parameter.
        \item When calling \ttt{fun("Hello")}, the initialization of the parameter could be seen as a \textbf{conversion} from \bluett{const char }\ttt{*} to \ttt{std::string}.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Constructors and Type-casting}
    Sometimes this will be confusing.
    \begin{cpp}
class Vector {
 public:
  Vector(std::size_t n)
    : m_size(n), m_capacity(n),
      m_data(new int[n]()) {}
};
int main() {
  Vector v = 10; // What??
  return 0;
}
    \end{cpp}
\end{frame}

\begin{frame}[fragile]{\bluett{explicit} Constructors}
    By defining a constructor as \bluett{explicit}, we disallow such conversion from happening implicitly.
    \begin{cpp}
class Vector {
 public:
  explicit Vector(std::size_t n)
    : m_size(n), m_capacity(n),
      m_data(new int[n]()) {}
};
int main() {
  Vector v1 = 10; // Error
  Vector v2(10);  // ok
  return 0;
}
    \end{cpp}
\end{frame}

\subsection{Friends}

\begin{frame}[fragile]{Friends}
    Code inside a \bluett{friend} of a class can access the private members of that class.
    \begin{cpp}
class Vector {
  friend bool equal_to(const Vector &, const Vector &);
  friend class SomeOtherClass;
  // other members
};
inline bool equal_to
    (const Vector &lhs, const Vector &rhs) {
  if (lhs.m_size != rhs.m_size)
    return false;
  for (std::size_t i = 0; i < lhs.m_size; ++i)
    if (lhs.m_data[i] != rhs.m_data[i])
      return false;
  return true;
}
    \end{cpp}
\end{frame}

\begin{frame}{Friends}
    \begin{itemize}
        \item A \bluett{friend} declaration is not a member of the class.
        \item Access-modifiers do not apply to \bluett{friend} declarations.
        \item \bluett{friend}s are often declared together at the beginning or end of the class.
    \end{itemize}
\end{frame}

\subsection{Constant Member Functions Revisited}

\begin{frame}[fragile]{Access Elements of Vector}
    \begin{cpp}
class Vector {
 public:
  int &at(std::size_t n) {
    return m_data[n];
  }
  // other members
};
    \end{cpp}
    What will happen on a \const object?
    \begin{cpp}
void print_vector(const Vector &v) {
  for (std::size_t i = 0; i < v.size(); ++i)
    std::cout << v.at(i) << " "; // Error!
}
    \end{cpp}
\end{frame}

\begin{frame}[fragile]{Access Elements of Vector}
    \begin{cpp}
class Vector {
 public:
  int &at(std::size_t n) const {
    return m_data[n];
  }
  // other members
};
    \end{cpp}
    \pause
    Still problematic:
    \begin{cpp}
const Vector v = some_value();
v.at(10) = 42;
    \end{cpp}
    Compilers may fail to detect such modification, but it is undefined behavior!
\end{frame}

\begin{frame}[fragile]{Correct Way}
    Const overloading.
    \begin{cpp}
class Vector {
 public:
  int &at(std::size_t n) {
    return m_data[n];
  }
  const int &at(std::size_t n) const {
    return m_data[n];
  }
  // other members
};
    \end{cpp}
    Calling a \const member function is actually \textbf{adding low-level \blue{const}} to the \bluett{this} pointer.
\end{frame}

\begin{frame}{Bitwise \const vs Logical \const}
    \begin{itemize}
        \item A member function is bitwise-\const if it does not modify any data member.
        \item A member function is logical-\const if it makes the object \textit{appear} unchanged to users.
        \begin{itemize}
            \item A logical-\const member function should prevent potential modification.
            \item A logical-\const member function may modify some data member, but the object seems unchanged to users.
        \end{itemize}
    \end{itemize}
    The compiler can only check bitwise constness.
\end{frame}

\begin{frame}[fragile]{Bitwise \const vs Logical \const}
    Bitwise-\const but not logical-\const:
    \begin{cpp}
class Vector {
 public:
  int &at(std::size_t n) const {
    return m_data[n];
  }
};
    \end{cpp}
    Directly returning a non-const reference to a data member is not allowed, but compilers may fail to detect this one.
\end{frame}

\begin{frame}[fragile]{\bluett{mutable} Member}
    What if we want to count how many times the function is called?
    \begin{cpp}
class Vector {
  int access_cnt;
 public:
  int &at(std::size_t n) {
    ++access_cnt;
    return m_data[n];
  }
  const int &at(std::size_t n) const {
    ++access_cnt;   // Oops! It is not bitwise-const!
    return m_data[n];
  }
};
    \end{cpp}
\end{frame}

\begin{frame}[fragile]{\bluett{mutable} Member}
    Define a member to be \bluett{mutable}, so that it is modifiable even in a \const member function.
    \begin{cpp}
class Vector {
  mutable int access_cnt;
 public:
  int &at(std::size_t n) {
    ++access_cnt;
    return m_data[n];
  }
  const int &at(std::size_t n) const {
    ++access_cnt;
    return m_data[n];
  }
};
    \end{cpp}
\end{frame}

\end{document}